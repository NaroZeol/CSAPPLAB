## 总体要求
***The bits.c file contains a skeleton for each of the 13 programming puzzles. Your assignment is to
complete each function skeleton using only straightline code for the integer puzzles (i.e., no loops or con-
ditionals) and a limited number of C arithmetic and logical operators. Specifically, you are only allowed to
use the following eight operators:
!  ̃ & ˆ | + << >>
A few of the functions further restrict this list. Also, you are not allowed to use any constants longer than 8
bits***

大致就是说，我们需要完成13个函数，每个函数只能使用上述8个操作符，**且不能使用大于8位的常数**，更具体的，每一题目还会有一些限制。

## 第一题
### 题意解析
该题要求仅使用“~”和“&”实现异或操作，要求最多符号不超过14个。

### 解答
```c
int xor(int a, int b) {
    return ~(~(a & ~b) & ~(~a & b));
}
```

### 思路
异或的真值表为

| A/B | 0 | 1 |   
| - | - | - |   
| 0 | 0 | 1 |  
| 1 | 1 | 0 |

而“A & ~B”和“~A & B”的真值表为

| A/B | 0 | 1 |
| - | - | - |
| 0 | 0 | 0 |
| 1 | 1 | 0 |

| A/B | 0 | 1 |
| - | - | - |
| 0 | 0 | 1 |
| 1 | 0 | 0 |

可以看出如果我们能够将两者进行一个或运算，那么就可以得到异或的结果。但问题在于题目不允许使用“|”操作符，所以我们需要想办法将两者进行一个或运算。因此我们需要借助摩根定律。

摩根定律告诉我们，对于任意的A和B，有
```
~(A & B) = ~A | ~B
~(A | B) = ~A & ~B
```
我们可以将其变形为
```
A | B = ~(~A & ~B)
```
这样我们得到了或运算。
将“A & ~B”和“~A & B”代入，我们得到
```
A ^ B = (A & ~B) | (~A & B) = ~(~(A & ~B) & ~(~A & B))
```
这样我们就可以得到异或的结果了。

## 第二题
### 题意解析
该题要求返回最小的二进制补码负数，要求只使用! ~ & ^ | + << >>
### 解答
```c
int min() {
    return 1 << 31;
}
```
### 思路
补码系统下数值与其二进制表示的关系为最高位设为负权，其余位设为正权，即
```
x = a[n-1] * (-2)^(n-1) + a[n-2] * 2^(n-2) + ... + a[1] * 2 + a[0]
```
其中a[n-1]为最高位，a[0]为最低位，n为二进制位数。因此为了让数值最小，我们只需要将最高位设为1，其余位设为0即可。既然题目允许使用移位操作，那么我们只需要将1左移31位即可得到最小的二进制补码负数。

## 第三题
### 题意解析
该题要求判断输入x是否是二进制补码系统下的最大正数，要求只使用! ~ & ^ | +

注意总体要求中的限制，不能使用大于8位的常数
### 解答
```c
int isTmax(int x) {
    return !(~((x + 1) ^ x)) & !!(x + 1);
}
```
### 思路
总体限制我们不能直接使用0X7FFFFFFF，因此我们需要想办法获取这个数或者找到最大正整数所满足的一些特殊规律。

个人在实践中没有找到通过给定操作获取最大正整数的方法，因此采用了另一种方法。

注意到题目给了我们“+”运算，假设我们的数位最多只有四位，则最大的正数为0111。将其加1后我们能得到1000。1000与0111做异或运算能够得到1111，**刚好用1填满了所有数位**，此时对其取反能够得到0000。可以证明只有0111和1111进行这样的操作之后能得到0000。因此只需将特殊情况-1排除后即可。

## 第四题
### 题意解析
该题要求判断一个数的所有奇数的位是否为1，要求只使用! ~ & ^ | + << >>
### 解答
```c
int allOddBits(int x) {
	int mask = 0xAA;
    mask = mask + (mask << 8) + (mask << 16) + (mask << 24);
    return !((x & mask) ^ mask);
}
```
### 思路
构造一个所有奇数位都为1的掩码（0xAAAAAAAA），然后和该掩码做与运算判断是否和掩码相等即可。注意总体要求我们不能使用大于8位的常数，因此我们需要先创建一个八位的奇数位都为1的掩码，然后再将其左移8位，16位，24位，最后将四个掩码相加即可。

## 第五题

### 题意解析
要求返回-x，要求只使用! ~ & ^ | + << >>

### 解答
```c
int negate(int x) {
    return ~x + 1;
}
```
### 思路
一个大家都明白的公式，在补码系统下
```
-x = ~x + 1
```

## 第六题

### 题意解析
判断输入的x是否满足 0x30(48) <= x <= 0x39(57)，即ascii码中数字0~9所对应的符号。
只允许使用! ~ & ^ | + << >>

### 解答
```c
int isAsciiDigit(int x) {
    int min_neg = ~0x2F;//-48
    int max_neg = ~0x39;//-(57 + 1)
    int sign_check = 1 << 31;

    return !!(~((x + min_neg) & sign_check ) & ((x + max_neg) & sign_check));
}
```

### 思路
该题要求完成比较操作

如果A > B，那么 A - B > 0，所以我们只要创造出相减数即可。

更具体的，我们构建出-48, 如果x - 48 >= 0，则x - 48的符号位将是表示非负数的0。我们只用检查符号位即可判断x是否大于等于48。

但对于小于等于操作，情况稍微有点不一样了。x <= 57，则有 x - 57 <= 0，问题在于小于判断和等于判断无法再一次通过检查符号位获得了，因此，我们应该改写x - 57 <= 0 为 x - 58 < 0，这样就可以判断x - 58的符号位是否为1来确认是否满足。

### 思考
如果阅读后面的章节我们会明白CPU中的判断是否大于小于不仅要去检查符号位，还要去检查溢出信号。这是因为如果一次运算造成了溢出，那么通过检查符号位来判断是否大于小于的方法就会得到相反的结果。但问题在于为什么本题没有发生这样的错误。这是因为我们的做法通过将两个涉及大于小于判断的计算的结果与在了一起，这导致就算发生了溢出两者的影响相互抵消了，所以总体上没有什么错误。但是要记住这个做法只不过是碰巧对了罢了。

## 第七题

### 题意解析
要求实现一个三目运算符，只可使用! ~ & ^ | + << >>

### 解答
```c
int conditional(int x, int y, int z) {
    int flag = ((!!x) << 31) >> 31;

    return (y & flag) | (z & ~flag);
}
```

### 思路
核心就在于如何表示选择关系。

注意到-1（即0xFFFFFFFF），每一位都为1，将其与某个数做与运算则可以表示原数，而对其取反（即0），将其与某个数做与运算则可以消除该数。

因此我们只需让flag在x为非零时为0xFFFFFFFF，而为零时为0。通过表达式(y & flag) | (z & ~flag)即可表示选择关系。

0xFFFFFFFF可以通过有符号数的右移补全符号位的规则得到。

## 第八题

### 题意解析
要求实现一个判断x是否小于等于y的函数，只可以使用! ~ & ^ | + << >>

### 解答
```c
int isLessOrEqual(int x, int y) {
    int neg_x = ~x + 1;//-x
    int sign = 1 << 31;//sign bit
    int res = neg_x + y;//y - x

	int neg_x_AND_sign = neg_x & sign;
	int y_AND_sign = y & sign;
	int res_AND_sign = res & sign;

    int overflow_check =(neg_x_AND_sign & y_AND_sign & ~res_AND_sign) | (~neg_x_AND_sign & ~y_AND_sign & res_AND_sign);

    return (!(res_AND_sign ^ overflow_check)) | !(x ^ sign);
}
```

### 思路
和第六题类似的思路，但这次没有神奇的关系抵消溢出的问题。（见第六题思考部分，通过加减然后检查符号位的做法会因为溢出而导致结果相反）

所以我们需要**修正加减法溢出时的错误**。

我们需要判断x <= y，可以改写为 0 <= y + (-x)，那么只需判断y + (-x)的符号并且修正溢出的问题即可。

那么如何判断两数相加溢出了呢。首先我们应该清楚什么情况下会发生溢出。


两数相加有三种情况：

    1.一个正数一个负数，此时无论如何都不会发生溢出。
    2.两个正数，溢出会导致结果为负数。
    3.两个负数，溢出会导致结果为正数。

因此我们可以发现判断条件为

    overflow_check = (As & Bs & ~Rs) | (~As & ~Bs & Rs)

其中As为一个数的符号位，Bs为另一个数的符号位，Rs为两者相加的结果的符号位。

在获得了是否溢出的信息后，我们可以通过异或操作来使得当溢出信号为1时反转结果。

&nbsp;

**在处理完溢出的问题后，该题还有一个很严重的问题没有解决。**
我们实现 y - x时要计算-x然后再相加。当x为一个比较正常的值的时候，这个计算运行十分ok，但是当x为0x80000000（即二进制补码数的最小值）时，没有与之对应的-x。比如说以四位补码数为例，1000为最小的值，其值为-8，但是四位补码数的最大值为7，所以说不存在8与-8对应，换到32位补码数也是一个道理。不过好在对于小于等于来说，只要x为0x80000000，结果都是1。所以我们只需要加一个特例判断即可。

因为中途可能会有很多重复的信号，我们可以选择使用变量暂存信号来减少符号的使用。

















