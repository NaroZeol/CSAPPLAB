## 总体要求
***The bits.c file contains a skeleton for each of the 13 programming puzzles. Your assignment is to
complete each function skeleton using only straightline code for the integer puzzles (i.e., no loops or con-
ditionals) and a limited number of C arithmetic and logical operators. Specifically, you are only allowed to
use the following eight operators:
!  ̃ & ˆ | + << >>
A few of the functions further restrict this list. Also, you are not allowed to use any constants longer than 8
bits***

大致就是说，我们需要完成13个函数，每个函数只能使用上述8个操作符，**且不能使用大于8位的常数**，更具体的，每一题目还会有一些限制。

## 第一题
### 题意解析
该题要求仅使用“~”和“&”实现异或操作，要求最多符号不超过14个。

### 解答
```c
int xor(int a, int b) {
    return ~(~(a & ~b) & ~(~a & b));
}
```

### 思路
异或的真值表为

| A/B | 0 | 1 |   
| - | - | - |   
| 0 | 0 | 1 |  
| 1 | 1 | 0 |

而“A & ~B”和“~A & B”的真值表为

| A/B | 0 | 1 |
| - | - | - |
| 0 | 0 | 0 |
| 1 | 1 | 0 |

| A/B | 0 | 1 |
| - | - | - |
| 0 | 0 | 1 |
| 1 | 0 | 0 |

可以看出如果我们能够将两者进行一个或运算，那么就可以得到异或的结果。但问题在于题目不允许使用“|”操作符，所以我们需要想办法将两者进行一个或运算。因此我们需要借助摩根定律。

摩根定律告诉我们，对于任意的A和B，有
```
~(A & B) = ~A | ~B
~(A | B) = ~A & ~B
```
我们可以将其变形为
```
A | B = ~(~A & ~B)
```
这样我们得到了或运算。
将“A & ~B”和“~A & B”代入，我们得到
```
A ^ B = (A & ~B) | (~A & B) = ~(~(A & ~B) & ~(~A & B))
```
这样我们就可以得到异或的结果了。

## 第二题
### 题意解析
该题要求返回最小的二进制补码负数，要求只使用! ~ & ^ | + << >>

注意总体要求中的限制，不能使用大于8位的常数
### 解答
```c
int min() {
    return 1 << 31;
}
```
### 思路
补码系统下数值与其二进制表示的关系为最高位设为负权，其余位设为正权，即
```
x = a[n-1] * (-2)^(n-1) + a[n-2] * 2^(n-2) + ... + a[1] * 2 + a[0]
```
其中a[n-1]为最高位，a[0]为最低位，n为二进制位数。因此为了让数值最小，我们只需要将最高位设为1，其余位设为0即可。既然题目允许使用移位操作，那么我们只需要将1左移31位即可得到最小的二进制补码负数。

## 第三题
### 题意解析
该题要求判断输入x是否是二进制补码系统下的最大正数，要求只使用! ~ & ^ | +
### 解答
```c
int isTmax(int x) {
    return !(~((x + 1) ^ x)) & !!(x + 1);
}
```
### 思路
总体限制我们不能直接使用0X7FFFFFFF，因此我们需要想办法获取这个数或者找到最大正整数所满足的一些特殊规律。

个人在实践中没有找到通过给定操作获取最大正整数的方法，因此采用了另一种方法。

注意到题目给了我们“+”法运算，假设我们的数位最多只有四位，则最大的正数为0111。将其加1后我们能得到1000。1000与0111做异或运算能够得到1111，**刚好用1填满了所有数位**，此时对其取反能够得到0000。可以证明只有0111和1111进行这样的操作之后能得到0000。因此只需将特殊情况-1排除后即可。




