## 总体要求
***The bits.c file contains a skeleton for each of the 13 programming puzzles. Your assignment is to
complete each function skeleton using only straightline code for the integer puzzles (i.e., no loops or con-
ditionals) and a limited number of C arithmetic and logical operators. Specifically, you are only allowed to
use the following eight operators:
!  ̃ & ˆ | + << >>
A few of the functions further restrict this list. Also, you are not allowed to use any constants longer than 8
bits***

大致就是说，我们需要完成13个函数，每个函数只能使用上述8个操作符，**且不能使用大于8位的常数**，更具体的，每一题目还会有一些限制。

## 第一题
### 题意解析
该题要求仅使用“~”和“&”实现异或操作，要求最多符号不超过14个。

### 解答
```c
int xor(int a, int b) {
    return ~(~(a & ~b) & ~(~a & b));
}
```

### 思路
异或的真值表为

| A/B | 0 | 1 |   
| - | - | - |   
| 0 | 0 | 1 |  
| 1 | 1 | 0 |

而“A & ~B”和“~A & B”的真值表为

| A/B | 0 | 1 |
| - | - | - |
| 0 | 0 | 0 |
| 1 | 1 | 0 |

| A/B | 0 | 1 |
| - | - | - |
| 0 | 0 | 1 |
| 1 | 0 | 0 |

可以看出如果我们能够将两者进行一个或运算，那么就可以得到异或的结果。但问题在于题目不允许使用“|”操作符，所以我们需要想办法将两者进行一个或运算。因此我们需要借助摩根定律。

摩根定律告诉我们，对于任意的A和B，有
```
~(A & B) = ~A | ~B
~(A | B) = ~A & ~B
```
我们可以将其变形为
```
A | B = ~(~A & ~B)
```
这样我们得到了或运算。
将“A & ~B”和“~A & B”代入，我们得到
```
A ^ B = (A & ~B) | (~A & B) = ~(~(A & ~B) & ~(~A & B))
```
这样我们就可以得到异或的结果了。

## 第二题
### 题意解析
该题要求返回最小的二进制补码负数，要求只使用! ~ & ^ | + << >>
### 解答
```c
int min() {
    return 1 << 31;
}
```
### 思路
补码系统下数值与其二进制表示的关系为最高位设为负权，其余位设为正权，即
```
x = a[n-1] * (-2)^(n-1) + a[n-2] * 2^(n-2) + ... + a[1] * 2 + a[0]
```
其中a[n-1]为最高位，a[0]为最低位，n为二进制位数。因此为了让数值最小，我们只需要将最高位设为1，其余位设为0即可。既然题目允许使用移位操作，那么我们只需要将1左移31位即可得到最小的二进制补码负数。

## 第三题
### 题意解析
该题要求判断输入x是否是二进制补码系统下的最大正数，要求只使用! ~ & ^ | +

注意总体要求中的限制，不能使用大于8位的常数
### 解答
```c
int isTmax(int x) {
    return !(~((x + 1) ^ x)) & !!(x + 1);
}
```
### 思路
总体限制我们不能直接使用0X7FFFFFFF，因此我们需要想办法获取这个数或者找到最大正整数所满足的一些特殊规律。

个人在实践中没有找到通过给定操作获取最大正整数的方法，因此采用了另一种方法。

注意到题目给了我们“+”运算，假设我们的数位最多只有四位，则最大的正数为0111。将其加1后我们能得到1000。1000与0111做异或运算能够得到1111，**刚好用1填满了所有数位**，此时对其取反能够得到0000。可以证明只有0111和1111进行这样的操作之后能得到0000。因此只需将特殊情况-1排除后即可。

## 第四题
### 题意解析
该题要求判断一个数的所有奇数的位是否为1，要求只使用! ~ & ^ | + << >>
### 解答
```c
int allOddBits(int x) {
	int mask = 0xAA;
    mask = mask + (mask << 8) + (mask << 16) + (mask << 24);
    return !((x & mask) ^ mask);
}
```
### 思路
构造一个所有奇数位都为1的掩码（0xAAAAAAAA），然后和该掩码做与运算判断是否和掩码相等即可。注意总体要求我们不能使用大于8位的常数，因此我们需要先创建一个八位的奇数位都为1的掩码，然后再将其左移8位，16位，24位，最后将四个掩码相加即可。

## 第五题

### 题意解析
要求返回-x，要求只使用! ~ & ^ | + << >>

### 解答
```c
int negate(int x) {
    return ~x + 1;
}
```
### 思路
一个大家都明白的公式，在补码系统下
```
-x = ~x + 1
```

## 第六题

### 题意解析
判断输入的x是否满足 0x30(48) <= x <= 0x39(57)，即ascii码中数字0~9所对应的符号。
只允许使用! ~ & ^ | + << >>

### 解答
```c
int isAsciiDigit(int x) {
    int min_neg = ~0x2F;//-48
    int max_neg = ~0x39;//-(57 + 1)
    int sign_check = 1 << 31;

    return !!(~((x + min_neg) & sign_check ) & ((x + max_neg) & sign_check));
}
```

### 思路

该题要求完成比较操作

如果A > B，那么 A - B > 0，所以我们只要创造出相减数即可。

更具体的，我们构建出-48, 如果x - 48 >= 0，则x - 48的符号位将是表示非负数的0。我们只用检查符号位即可判断x是否大于等于48。

但对于小于等于操作，情况稍微有点不一样了。x <= 57，则有 x - 57 <= 0，问题在于小于判断和等于判断无法再一次通过检查符号位获得了，因此，我们应该改写x - 57 <= 0 为 x - 58 < 0，这样就可以判断x - 58的符号位是否为1来确认是否满足。

### 思考
如果阅读后面的章节我们会明白CPU中的判断是否大于小于不仅要去检查符号位，还要去检查溢出信号。这是因为如果一次运算造成了溢出，那么通过检查符号位来判断是否大于小于的方法就会得到相反的结果。但问题在于为什么本题没有发生这样的错误。这是因为我们的做法通过将两个涉及大于小于判断的计算的结果与在了一起，这导致就算发生了溢出两者的影响相互抵消了，所以总体上没有什么错误。但是要记住这个做法只不过是碰巧对了罢了。









