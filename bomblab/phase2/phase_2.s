phase_2:
   0x0000000000400efc <+0>:     push   %rbp
   0x0000000000400efd <+1>:     push   %rbx
   0x0000000000400efe <+2>:     sub    $0x28,%rsp #分配栈空间，开辟了一个数组int a[6]，数组的首地址为%rsp
   0x0000000000400f02 <+6>:     mov    %rsp,%rsi #暂存数组首地址，作为read_six_numbers的参数，用于存放输入的六个数字
   0x0000000000400f05 <+9>:     call   0x40145c <read_six_numbers>
   #现在%rsp到%rsp+24的空间中存放了六个数字，分别为a[0]~a[5]，类型为int
   
   0x0000000000400f0a <+14>:    cmpl   $0x1,(%rsp) #检查a[0]是否为1
   0x0000000000400f0e <+18>:    je     0x400f30 <phase_2+52>
   0x0000000000400f10 <+20>:    call   0x40143a <explode_bomb>#如果a[0]不为1，则炸弹爆炸

   0x0000000000400f15 <+25>:    jmp    0x400f30 <phase_2+52>
   0x0000000000400f17 <+27>:    mov    -0x4(%rbx),%eax #eax=a[i-1]
   0x0000000000400f1a <+30>:    add    %eax,%eax #eax=2*a[i-1]
   0x0000000000400f1c <+32>:    cmp    %eax,(%rbx) #检查a[i]是否等于2*a[i-1]
   0x0000000000400f1e <+34>:    je     0x400f25 <phase_2+41>
   0x0000000000400f20 <+36>:    call   0x40143a <explode_bomb>
   0x0000000000400f25 <+41>:    add    $0x4,%rbx #rbx指向a[i+1]
   0x0000000000400f29 <+45>:    cmp    %rbp,%rbx #检查rbx是否指向%rsp+24
   0x0000000000400f2c <+48>:    jne    0x400f17 <phase_2+27>
   0x0000000000400f2e <+50>:    jmp    0x400f3c <phase_2+64>

   0x0000000000400f30 <+52>:    lea    0x4(%rsp),%rbx #rbx指向a[1]
   0x0000000000400f35 <+57>:    lea    0x18(%rsp),%rbp #rbp指向%rsp+24，这个地址是数组的终点，可以用来作为循环结束的标志
   0x0000000000400f3a <+62>:    jmp    0x400f17 <phase_2+27>

   0x0000000000400f3c <+64>:    add    $0x28,%rsp
   0x0000000000400f40 <+68>:    pop    %rbx
   0x0000000000400f41 <+69>:    pop    %rbp
   0x0000000000400f42 <+70>:    ret    

read_six_numbers:
   0x000000000040145c <+0>:     sub    $0x18,%rsp  #开辟栈空间
   0x0000000000401460 <+4>:     mov    %rsi,%rdx 
   0x0000000000401463 <+7>:     lea    0x4(%rsi),%rcx 
   0x0000000000401467 <+11>:    lea    0x14(%rsi),%rax 
   0x000000000040146b <+15>:    mov    %rax,0x8(%rsp) 
   0x0000000000401470 <+20>:    lea    0x10(%rsi),%rax 
   0x0000000000401474 <+24>:    mov    %rax,(%rsp) 
   0x0000000000401478 <+28>:    lea    0xc(%rsi),%r9 
   0x000000000040147c <+32>:    lea    0x8(%rsi),%r8
   #  至此：%rdx->%rsi   %rcx->%rsi+4   %r8->%rsi+8   %r9->%rsi+12 
   #       (%rsp)->%rsi+16   (%rsp+8)->%rsi+20  
   #  如果认为%rsi代表了数组a，则可以认为
   #       %rdx->&a[0]   %rcx->&a[1]   %r8->&a[2]   %r9->&a[3]
   #       (%rsp)->&a[4]   (%rsp+8)->&a[5] (寄存器不够用了，只能用栈了)
   #  a[0]的类型为int，数组a为phase_2中的局部变量
   0x0000000000401480 <+36>:    mov    $0x4025c3,%esi #"%d %d %d %d %d %d"
   0x0000000000401485 <+41>:    mov    $0x0,%eax #eax=0
   0x000000000040148a <+46>:    call   0x400bf0 <__isoc99_sscanf@plt> #sscanf($输入字符串$,"%d %d %d %d %d %d",&a[0],&a[1],&a[2],&a[3],&a[4],&a[5])
   0x000000000040148f <+51>:    cmp    $0x5,%eax #检查输入的数字是否为大于等于6个
   0x0000000000401492 <+54>:    jg     0x401499 <read_six_numbers+61>
   0x0000000000401494 <+56>:    call   0x40143a <explode_bomb>
   0x0000000000401499 <+61>:    add    $0x18,%rsp
   0x000000000040149d <+65>:    ret 

0x4025c3:       "%d %d %d %d %d %d"