>The nefarious Dr. Evil has planted a slew of “binary bombs” on our class machines. A binary bomb is a
program that consists of a sequence of phases. Each phase expects you to type a particular string on stdin.
If you type the correct string, then the phase is defused and the bomb proceeds to the next phase. Otherwise,
the bomb explodes by printing "BOOM!!!" and then terminating. The bomb is defused when every phase
has been defused.
There are too many bombs for us to deal with, so we are giving each student a bomb to defuse. Your
mission, which you have no choice but to accept, is to defuse your bomb before the due date. Good luck,
and welcome to the bomb squad!

邪恶的Evil博士在我们的课堂机器上种植了一大堆“二进制炸弹”。二进制炸弹是一个由一系列阶段组成的程序。每个阶段都希望你在stdin上键入一个特定的字符串。如果你键入正确的字符串，那么阶段就被拆除了，炸弹就会进入下一个阶段。否则，炸弹会打印“BOOM!!!”，然后终止。当每个阶段都被拆除时，炸弹就被拆除了。

也就是说，我们需要在每个阶段输入一个字符串，如果输入正确，就会进入下一个阶段，如果输入错误，就会爆炸。

具体确定每个阶段的输入字符串，我们需要通过反汇编来确定。

可以使用gdb来进行反汇编。

```bash
gdb bomb
disas main
```
得到的main函数的核心代码如下：

```asm
main:
   0x0000000000400e32 <+146>:   call   0x40149e <read_line>
   0x0000000000400e37 <+151>:   mov    %rax,%rdi
   0x0000000000400e3a <+154>:   call   0x400ee0 <phase_1>
   0x0000000000400e3f <+159>:   call   0x4015c4 <phase_defused>
   0x0000000000400e44 <+164>:   mov    $0x4023a8,%edi
   0x0000000000400e49 <+169>:   call   0x400b10 <puts@plt>
   0x0000000000400e4e <+174>:   call   0x40149e <read_line>
   0x0000000000400e53 <+179>:   mov    %rax,%rdi
   0x0000000000400e56 <+182>:   call   0x400efc <phase_2>
   0x0000000000400e5b <+187>:   call   0x4015c4 <phase_defused>
   0x0000000000400e60 <+192>:   mov    $0x4022ed,%edi
   0x0000000000400e65 <+197>:   call   0x400b10 <puts@plt>
   0x0000000000400e6a <+202>:   call   0x40149e <read_line>
   0x0000000000400e6f <+207>:   mov    %rax,%rdi
   0x0000000000400e72 <+210>:   call   0x400f43 <phase_3>
   0x0000000000400e77 <+215>:   call   0x4015c4 <phase_defused>
   0x0000000000400e7c <+220>:   mov    $0x40230b,%edi
   0x0000000000400e81 <+225>:   call   0x400b10 <puts@plt>
   0x0000000000400e86 <+230>:   call   0x40149e <read_line>
   0x0000000000400e8b <+235>:   mov    %rax,%rdi
   0x0000000000400e8e <+238>:   call   0x40100c <phase_4>
   0x0000000000400e93 <+243>:   call   0x4015c4 <phase_defused>
   0x0000000000400e98 <+248>:   mov    $0x4023d8,%edi
   0x0000000000400e9d <+253>:   call   0x400b10 <puts@plt>
   0x0000000000400ea2 <+258>:   call   0x40149e <read_line>
   0x0000000000400ea7 <+263>:   mov    %rax,%rdi
   0x0000000000400eaa <+266>:   call   0x401062 <phase_5>
   0x0000000000400eaf <+271>:   call   0x4015c4 <phase_defused>
   0x0000000000400eb4 <+276>:   mov    $0x40231a,%edi
   0x0000000000400eb9 <+281>:   call   0x400b10 <puts@plt>
   0x0000000000400ebe <+286>:   call   0x40149e <read_line>
   0x0000000000400ec3 <+291>:   mov    %rax,%rdi
   0x0000000000400ec6 <+294>:   call   0x4010f4 <phase_6>
   0x0000000000400ecb <+299>:   call   0x4015c4 <phase_defused>
   0x0000000000400ed0 <+304>:   mov    $0x0,%eax
   0x0000000000400ed5 <+309>:   pop    %rbx
   0x0000000000400ed6 <+310>:   ret  
```

可以发现，每个阶段都是通过调用read_line函数来读取输入的字符串，然后调用对应的phase函数来判断输入的字符串是否正确。因此我们需要将注意力放在每个phase函数上。

## Phase 1
read_line将读取到的字符串的首地址存放于%rax中，然后将%rax的值传递给%rdi，然后调用phase_1函数，就是说在phase_1函数中，我们可以通过%rdi来获取输入的字符串。%rdi一般用于存放第一个参数。


在gdb中输入
```bash
disas phase_1
```

得到的phase_1函数的核心代码如下：

```asm
   0x0000000000400ee0 <+0>:     sub    $0x8,%rsp
   0x0000000000400ee4 <+4>:     mov    $0x402400,%esi
   0x0000000000400ee9 <+9>:     call   0x401338 <strings_not_equal>
   0x0000000000400eee <+14>:    test   %eax,%eax
   0x0000000000400ef0 <+16>:    je     0x400ef7 <phase_1+23>
   0x0000000000400ef2 <+18>:    call   0x40143a <explode_bomb>
   0x0000000000400ef7 <+23>:    add    $0x8,%rsp
   0x0000000000400efb <+27>:    ret    
```
函数将0x402400存放于%esi中，然后调用一个名叫strings_not_equal的函数。从名字我们猜测，这个函数是用来比较两个字符串是否不相等的。如果我们用gdb查看这个函数的代码，可以发现，这个函数的功能就是比较两个字符串是否相等，如果相等，返回0，否则返回1，这里不对这个函数进行分析了。

string_not_equal函数使用了两个寄存器来获取两个字符串的首地址，分别是%rdi和%rsi。%rsi即为0x402400。因此我们需要查看%rdi的值，即输入的字符串的首地址。

在gdb中输入
```bash
x/s 0x402400
```
可以得到0x402400处的字符串为
```asm
0x402400:       "Border relations with Canada have never been better."
```

输入这个字符串，即可通过第一关。

## Phase 2
在gdb中输入
```asm
disas phase_2
```
可以得到phase_2的反汇编代码。

下面我们逐步分析phase_2的代码。
```asm
phase_2:
   0x0000000000400efc <+0>:     push   %rbp
   0x0000000000400efd <+1>:     push   %rbx
   0x0000000000400efe <+2>:     sub    $0x28,%rsp #分配栈空间，开辟了一个数组int a[6]，数组的首地址为%rsp
   0x0000000000400f02 <+6>:     mov    %rsp,%rsi #暂存数组首地址，作为read_six_numbers的参数，用于存放输入的六个数字
   0x0000000000400f05 <+9>:     call   0x40145c <read_six_numbers>
```
read_six_numbers函数，根据函数名可猜测是从输入字符串中读取六个数字，然后存放到%rsi指向的数组中。

read_six_numbers函数的反汇编代码如下：
```asm
read_six_numbers:
   0x000000000040145c <+0>:     sub    $0x18,%rsp  #开辟栈空间
   0x0000000000401460 <+4>:     mov    %rsi,%rdx 
   0x0000000000401463 <+7>:     lea    0x4(%rsi),%rcx 
   0x0000000000401467 <+11>:    lea    0x14(%rsi),%rax 
   0x000000000040146b <+15>:    mov    %rax,0x8(%rsp) 
   0x0000000000401470 <+20>:    lea    0x10(%rsi),%rax 
   0x0000000000401474 <+24>:    mov    %rax,(%rsp) 
   0x0000000000401478 <+28>:    lea    0xc(%rsi),%r9 
   0x000000000040147c <+32>:    lea    0x8(%rsi),%r8
   #  至此：%rdx->%rsi   %rcx->%rsi+4   %r8->%rsi+8   %r9->%rsi+12 
   #       (%rsp)->%rsi+16   (%rsp+8)->%rsi+20  
   #  如果认为%rsi代表了数组a，则可以认为
   #       %rdx->&a[0]   %rcx->&a[1]   %r8->&a[2]   %r9->&a[3]
   #       (%rsp)->&a[4]   (%rsp+8)->&a[5] (寄存器不够用了，只能用栈了)
   #  a[0]的类型为int，数组a为phase_2中的局部变量
   0x0000000000401480 <+36>:    mov    $0x4025c3,%esi #"%d %d %d %d %d %d"
   0x0000000000401485 <+41>:    mov    $0x0,%eax #eax=0
   0x000000000040148a <+46>:    call   0x400bf0 <__isoc99_sscanf@plt> #sscanf($输入字符串$,"%d %d %d %d %d %d",&a[0],&a[1],&a[2],&a[3],&a[4],&a[5])
   0x000000000040148f <+51>:    cmp    $0x5,%eax #检查输入的数字是否为大于等于6个
   0x0000000000401492 <+54>:    jg     0x401499 <read_six_numbers+61>
   0x0000000000401494 <+56>:    call   0x40143a <explode_bomb>
   0x0000000000401499 <+61>:    add    $0x18,%rsp
   0x000000000040149d <+65>:    ret 
```

%esi中存放模式字符串的地址0x4025c3，通过反汇编查看该处的字符串可以得知，该字符串为"%d %d %d %d %d %d"，即输入的字符串应该是由六个数字组成的，这帮助我们更好的理解了这个函数的行为。

该函数首先开辟了一个24字节栈空间，然后将%rsi(存放着phase_2开辟的数组a的首地址)的值赋给%rdx，将%rsi+4的值赋给%rcx，将%rsi+8的值赋给%r8，将%rsi+12的值赋给%r9，将%rsi+16的值赋给(%rsp)，将%rsi+20的值赋给(%rsp+8)，也就是说该函数创造了六个参数作为sscanf的输出。

所以在read_six_numbers函数执行完毕后，数组a中的值为输入字符串中的六个数字。

我们需要让这六个数字符合phase_2的要求，这需要继续分析phase_2的代码。

```asm
   #现在%rsp到%rsp+24的空间中存放了六个数字，分别为a[0]~a[5]，类型为int
   
   0x0000000000400f0a <+14>:    cmpl   $0x1,(%rsp) #检查a[0]是否为1
   0x0000000000400f0e <+18>:    je     0x400f30 <phase_2+52>
   0x0000000000400f10 <+20>:    call   0x40143a <explode_bomb>#如果a[0]不为1，则炸弹爆炸

   0x0000000000400f15 <+25>:    jmp    0x400f30 <phase_2+52>
   0x0000000000400f17 <+27>:    mov    -0x4(%rbx),%eax #eax=a[i-1]
   0x0000000000400f1a <+30>:    add    %eax,%eax #eax=2*a[i-1]
   0x0000000000400f1c <+32>:    cmp    %eax,(%rbx) #检查a[i]是否等于2*a[i-1]
   0x0000000000400f1e <+34>:    je     0x400f25 <phase_2+41>
   0x0000000000400f20 <+36>:    call   0x40143a <explode_bomb>
   0x0000000000400f25 <+41>:    add    $0x4,%rbx #rbx指向a[i+1]
   0x0000000000400f29 <+45>:    cmp    %rbp,%rbx #检查rbx是否指向%rsp+24
   0x0000000000400f2c <+48>:    jne    0x400f17 <phase_2+27>
   0x0000000000400f2e <+50>:    jmp    0x400f3c <phase_2+64>

   0x0000000000400f30 <+52>:    lea    0x4(%rsp),%rbx #rbx指向a[1]
   0x0000000000400f35 <+57>:    lea    0x18(%rsp),%rbp #rbp指向%rsp+24，这个地址是数组的终点，可以用来作为循环结束的标志
   0x0000000000400f3a <+62>:    jmp    0x400f17 <phase_2+27>

   0x0000000000400f3c <+64>:    add    $0x28,%rsp
   0x0000000000400f40 <+68>:    pop    %rbx
   0x0000000000400f41 <+69>:    pop    %rbp
   0x0000000000400f42 <+70>:    ret  
```

根据反汇编我们可以推测该部分对应的C语言代码为：
```c
if(a[0] != 1)
    explode_bomb();
for(int i = 1; i < 6; i++)
{
    if(a[i] != 2 * a[i - 1] )
        explode_bomb();
}
```
所以我们要输入的六个数就是“1 2 4 8 16 32”。

## Phase 3
在gdb中输入
```bash
disas phase_3
```
可以得到phase_3的反汇编代码。

前半部分代码如下：
```asm
   0x0000000000400f43 <+0>:     sub    $0x18,%rsp #开辟24个字节的空间
   0x0000000000400f47 <+4>:     lea    0xc(%rsp),%rcx #sscnf的第二个输出参数，设其为b
   0x0000000000400f4c <+9>:     lea    0x8(%rsp),%rdx #sscnf的第一个输出参数，设其为a
   0x0000000000400f51 <+14>:    mov    $0x4025cf,%esi
   0x0000000000400f56 <+19>:    mov    $0x0,%eax
   0x0000000000400f5b <+24>:    call   0x400bf0 <__isoc99_sscanf@plt> #sscanf($输入字符串$, "%d %d", &a, &b)
   0x0000000000400f60 <+29>:    cmp    $0x1,%eax
   0x0000000000400f63 <+32>:    jg     0x400f6a <phase_3+39>
   0x0000000000400f65 <+34>:    call   0x40143a <explode_bomb>
   0x0000000000400f6a <+39>:    cmpl   $0x7,0x8(%rsp) #比较a和7的大小
   0x0000000000400f6f <+44>:    ja     0x400fad <phase_3+106> #如果a>7，就爆炸
   0x0000000000400f71 <+46>:    mov    0x8(%rsp),%eax #将a的值赋给eax
   0x0000000000400f75 <+50>:    jmp    *0x402470(,%rax,8) #跳转到*(0x402470+8*a)的地址
```

可以发现该题的核心在于跳转表，跳转表的地址为0x402470，跳转表的内容如下：
```asm
0x402470:       0x0000000000400f7c <phase_3 + 57>
0x402478:       0x0000000000400fb9 <phase_3 +118>
0x402480:       0x0000000000400f83 <phase_3 + 64>
0x402480:       0x0000000000400f8a <phase_3 + 71>
0x402490:       0x0000000000400f91 <phase_3 + 78>
0x402498:       0x0000000000400f98 <phase_3 + 85>
0x4024a0:       0x0000000000400f9f <phase_3 + 92>
0x4024a8:       0x0000000000400fa6 <phase_3 + 99>
```

当输入的第一个数字为0~7时，就会跳转到对应的地址，然后执行对应的代码。

下一半反汇编代码如下：
```asm
   0x0000000000400f7c <+57>:    mov    $0xcf,%eax
   0x0000000000400f81 <+62>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f83 <+64>:    mov    $0x2c3,%eax
   0x0000000000400f88 <+69>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f8a <+71>:    mov    $0x100,%eax
   0x0000000000400f8f <+76>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f91 <+78>:    mov    $0x185,%eax
   0x0000000000400f96 <+83>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f98 <+85>:    mov    $0xce,%eax
   0x0000000000400f9d <+90>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f9f <+92>:    mov    $0x2aa,%eax
   0x0000000000400fa4 <+97>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400fa6 <+99>:    mov    $0x147,%eax
   0x0000000000400fab <+104>:   jmp    0x400fbe <phase_3+123>
   0x0000000000400fad <+106>:   call   0x40143a <explode_bomb>
   0x0000000000400fb2 <+111>:   mov    $0x0,%eax
   0x0000000000400fb7 <+116>:   jmp    0x400fbe <phase_3+123>
   0x0000000000400fb9 <+118>:   mov    $0x137,%eax
   0x0000000000400fbe <+123>:   cmp    0xc(%rsp),%eax
   0x0000000000400fc2 <+127>:   je     0x400fc9 <phase_3+134>
   0x0000000000400fc4 <+129>:   call   0x40143a <explode_bomb>
   0x0000000000400fc9 <+134>:   add    $0x18,%rsp
   0x0000000000400fcd <+138>:   ret    
```

核心在于0x0000000000400fbe <+123>处的cmp指令，该指令比较0xc(%rsp)和%eax的值。即第二个输入的数字和%eax进行比较。如果相等，则通过，否则爆炸。

%eax根据跳转表的选择不同，对应的结果也不同，所以本题的答案有多个。

分别为
 
- "0 207" 
- "1 311"
- "2 707"
- "3 256"
- "4 389"
- "5 206"
- "6 682"
- "7 327"

 ## Phase4

 在gdb中输入
```bash
disas phase_4
```
可以得到phase_4的反汇编代码。
```asm
phase_4:
   0x000000000040100c <+0>:     sub    $0x18,%rsp
   0x0000000000401010 <+4>:     lea    0xc(%rsp),%rcx #sscanf的第二个输出参数，设其为b
   0x0000000000401015 <+9>:     lea    0x8(%rsp),%rdx #sscanf的第一个输出参数，设其为a
   0x000000000040101a <+14>:    mov    $0x4025cf,%esi
   0x000000000040101f <+19>:    mov    $0x0,%eax
   0x0000000000401024 <+24>:    call   0x400bf0 <__isoc99_sscanf@plt> #sscanf($输入字符串$, "%d %d", &a, &b)
   0x0000000000401029 <+29>:    cmp    $0x2,%eax
   0x000000000040102c <+32>:    jne    0x401035 <phase_4+41> #如果sscanf的返回值不为2，则爆炸
   0x000000000040102e <+34>:    cmpl   $0xe,0x8(%rsp) #如果a不小于等于14，则爆炸
   0x0000000000401033 <+39>:    jbe    0x40103a <phase_4+46> #jump if below or equal
   0x0000000000401035 <+41>:    call   0x40143a <explode_bomb>
   0x000000000040103a <+46>:    mov    $0xe,%edx   # %edx的初始值为14
   0x000000000040103f <+51>:    mov    $0x0,%esi   # %esi的初始值为0
   0x0000000000401044 <+56>:    mov    0x8(%rsp),%edi # a的值存放于%rdi
   0x0000000000401048 <+60>:    call   0x400fce <func4>
   0x000000000040104d <+65>:    test   %eax,%eax   # 如果func4的返回值不为0，则爆炸，也就是说我们希望func4的返回值为0
   0x000000000040104f <+67>:    jne    0x401058 <phase_4+76>
   0x0000000000401051 <+69>:    cmpl   $0x0,0xc(%rsp)
   0x0000000000401056 <+74>:    je     0x40105d <phase_4+81>
   0x0000000000401058 <+76>:    call   0x40143a <explode_bomb>
   0x000000000040105d <+81>:    add    $0x18,%rsp
   0x0000000000401061 <+85>:    ret  
```

查询0x4025cf可以看到内容为"%d %d"，所以我们要输入的字符串应该包含两个数字。

再往下可以看到phase4的核心在于调用的func4函数。

func4的反汇编如下；
```asm
#递归函数，输入为%edi，%esi，%edx，输出为%eax
#初始化时%esi为0，%edx为14，%edi为a
func4:
   0x0000000000400fce <+0>:     sub    $0x8,%rsp #没有压栈的操作。
   0x0000000000400fd2 <+4>:     mov    %edx,%eax
   0x0000000000400fd4 <+6>:     sub    %esi,%eax # %eax = %edx - %esi
   0x0000000000400fd6 <+8>:     mov    %eax,%ecx  # %ecx = %eax
   0x0000000000400fd8 <+10>:    shr    $0x1f,%ecx # %ecx = (%edx - %esi) >> 31， 这种操作一般用于获得符号位
   0x0000000000400fdb <+13>:    add    %ecx,%eax # %eax = %eax + %ecx(因为上一步是逻辑右移，%ecx为0或1)
   0x0000000000400fdd <+15>:    sar    %eax #当sar的操作数为1时，默认为算数右移一位，即除以2
   0x0000000000400fdf <+17>:    lea    (%rax,%rsi,1),%ecx # %ecx = %rax + %rsi = %eax + %esi
   # 如果设%esi为x，%edx为y，则以上操作可总结为
   # %eax = ((y - x) + (y - x < 0)) / 2 
   # %ecx = (y + (y - x < 0)) / 2
   0x0000000000400fe2 <+20>:    cmp    %edi,%ecx
   0x0000000000400fe4 <+22>:    jle    0x400ff2 <func4+36> #如果%ecx小于等于a，则跳转到0x400ff2
   0x0000000000400fe6 <+24>:    lea    -0x1(%rcx),%edx  # %edx = %ecx - 1
   0x0000000000400fe9 <+27>:    call   0x400fce <func4> #递归调用
   0x0000000000400fee <+32>:    add    %eax,%eax # %eax = 2 * %eax
   0x0000000000400ff0 <+34>:    jmp    0x401007 <func4+57> #跳转到0x401007，返回值为2 * %eax

   0x0000000000400ff2 <+36>:    mov    $0x0,%eax
   0x0000000000400ff7 <+41>:    cmp    %edi,%ecx           #可以发现只要%ecx等于a，就会返回0
   0x0000000000400ff9 <+43>:    jge    0x401007 <func4+57> # 如果%ecx大于等于a，则跳转到0x401007，返回值为0
   0x0000000000400ffb <+45>:    lea    0x1(%rcx),%esi      # %esi = %ecx + 1
   0x0000000000400ffe <+48>:    call   0x400fce <func4> #递归调用
   0x0000000000401003 <+53>:    lea    0x1(%rax,%rax,1),%eax # %eax = 2 * %eax + 1
   0x0000000000401007 <+57>:    add    $0x8,%rsp
   0x000000000040100b <+61>:    ret    
```

观察到func4中存在call func4的递归调用，因此可以确定该函数为一个递归函数。

对于递归函数，最好的方式还是去将程序翻译成C语言，具体的解析可以看代码中的注释，一条条的进行解析。

一个猜测的C语言程序如下：

```c
int func4(int x, int y, int a){
    int ecx =  (y + (y - x < 0)) / 2;

    if (ecx > a){
        return 2 * func4(x, ecx - 1, a);
    }   
    
    int ret = 0;
    if (ecx < a){
        ret = func4(ecx + 1, y, a);
        return 2 * ret + 1;
    }

    return 0;
}
```

经过测试，有以下答案能让该函数返回0的值有

- 0
- 1
- 3
- 7

这几个数都可以作为输入字符串中的第一个数字。

然后我们再去查看phase4 <+69>处检查第二个输入数字与0的关系，如果等于零则函数结束。

所以最终答案为以上4个数字之一与0组成的字符串

- 0 0
- 1 0
- 3 0
- 7 0

这题总感觉出的很奇怪，不知道想要考察什么，因为如果去阅读汇编，会发现func4在输入为7的时候在第一层就会返回0，根本连递归都不涉及。然后第二个数字的设计也太显然了。。。