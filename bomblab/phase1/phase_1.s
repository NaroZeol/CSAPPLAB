phase_1:
   0x0000000000400ee0 <+0>:     sub    $0x8,%rsp
   0x0000000000400ee4 <+4>:     mov    $0x402400,%esi #%esi一般用于存放第二个参数，0x402400是测试字符串的地址
   0x0000000000400ee9 <+9>:     call   0x401338 <strings_not_equal> #注意此时%rdi仍然为我们输入的字符串的地址
   0x0000000000400eee <+14>:    test   %eax,%eax
   0x0000000000400ef0 <+16>:    je     0x400ef7 <phase_1+23> #如果返回值为0，说明两个字符串相等，跳转到+23处
   0x0000000000400ef2 <+18>:    call   0x40143a <explode_bomb>
   0x0000000000400ef7 <+23>:    add    $0x8,%rsp
   0x0000000000400efb <+27>:    ret    

strings_not_equal:
   0x0000000000401338 <+0>:     push   %r12
   0x000000000040133a <+2>:     push   %rbp
   0x000000000040133b <+3>:     push   %rbx
   0x000000000040133c <+4>:     mov    %rdi,%rbx #%rbx暂存输入字符串的地址
   0x000000000040133f <+7>:     mov    %rsi,%rbp #%rbp暂存测试字符串的地址
   0x0000000000401342 <+10>:    call   0x40131b <string_length> #计算测试字符串的长度，输入为此时%rdi的值，即输入字符串的地址
   0x0000000000401347 <+15>:    mov    %eax,%r12d  #%r12d输入字符串的长度
   0x000000000040134a <+18>:    mov    %rbp,%rdi   #更新%rdi为测试字符串的地址
   0x000000000040134d <+21>:    call   0x40131b <string_length> 
   0x0000000000401352 <+26>:    mov    $0x1,%edx   #%edx用于存放返回值，1为不相等，0为相等
   0x0000000000401357 <+31>:    cmp    %eax,%r12d  #比较两个字符串的长度，%eax为测试字符串的长度
   0x000000000040135a <+34>:    jne    0x40139b <strings_not_equal+99>

   #此处翻译的循环模式为guarded-do，先测试一次，再判断是否继续循环，也就是do-while循环
   0x000000000040135c <+36>:    movzbl (%rbx),%eax #将输入字符串的第一个字符赋值给%eax
   0x000000000040135f <+39>:    test   %al,%al    #测试%al的值是否为0，%al是%eax的最低字节，即输入字符串的第一个字符是否为0
   0x0000000000401361 <+41>:    je     0x401388 <strings_not_equal+80> #如果为0，则说明输入字符串为空，跳转到+80处，准备返回1
   0x0000000000401363 <+43>:    cmp    0x0(%rbp),%al #比较%rbx（指向测试字符串）和%rbp（指向输入字符串）
   0x0000000000401366 <+46>:    je     0x401372 <strings_not_equal+58> #如果相等，跳转到+58处，更新%rbx和%rbp的值，即指向下一个字符
   0x0000000000401368 <+48>:    jmp    0x40138f <strings_not_equal+87> #如果不相等，跳转到+87处，准备返回1
   #以上为do-while循环的do部分，即先执行一次，再判断是否继续循环
   0x000000000040136a <+50>:    cmp    0x0(%rbp),%al  #比较%rbx（指向测试字符串）和%rbp（指向输入字符串）
   0x000000000040136d <+53>:    nopl   (%rax) #nopl指令，不做任何操作，只是为了占用一些空间，方便CPU做一些优化
   0x0000000000401370 <+56>:    jne    0x401396 <strings_not_equal+94> #如果不相等，跳转到+94处，准备返回1
   0x0000000000401372 <+58>:    add    $0x1,%rbx
   0x0000000000401376 <+62>:    add    $0x1,%rbp
   0x000000000040137a <+66>:    movzbl (%rbx),%eax
   0x000000000040137d <+69>:    test   %al,%al #检查%al是否为0
   0x000000000040137f <+71>:    jne    0x40136a <strings_not_equal+50> #如果不为0，说明还没有到字符串的结尾，继续循环

   0x0000000000401381 <+73>:    mov    $0x0,%edx #如果为0，说明已经到字符串的结尾，准备返回0
   0x0000000000401386 <+78>:    jmp    0x40139b <strings_not_equal+99>
   0x0000000000401388 <+80>:    mov    $0x0,%edx
   0x000000000040138d <+85>:    jmp    0x40139b <strings_not_equal+99> #不知道为什么此处会生成重复的代码
   0x000000000040138f <+87>:    mov    $0x1,%edx
   0x0000000000401394 <+92>:    jmp    0x40139b <strings_not_equal+99> #此条语句在此其实没有任何意义
   0x0000000000401396 <+94>:    mov    $0x1,%edx

   0x000000000040139b <+99>:    mov    %edx,%eax #将%edx的值赋给%eax，即返回值
   0x000000000040139d <+101>:   pop    %rbx
   0x000000000040139e <+102>:   pop    %rbp
   0x000000000040139f <+103>:   pop    %r12
   0x00000000004013a1 <+105>:   ret    

string_length:
   0x000000000040131b <+0>:     cmpb   $0x0,(%rdi) #%rdi一般用于存放第一个参数
   0x000000000040131e <+3>:     je     0x401332 <string_length+23>
   0x0000000000401320 <+5>:     mov    %rdi,%rdx
   0x0000000000401323 <+8>:     add    $0x1,%rdx
   0x0000000000401327 <+12>:    mov    %edx,%eax
   0x0000000000401329 <+14>:    sub    %edi,%eax
   0x000000000040132b <+16>:    cmpb   $0x0,(%rdx)
   0x000000000040132e <+19>:    jne    0x401323 <string_length+8>
   0x0000000000401330 <+21>:    repz ret 
   0x0000000000401332 <+23>:    mov    $0x0,%eax
   0x0000000000401337 <+28>:    ret    


0x402400:       "Border relations with Canada have never been better."