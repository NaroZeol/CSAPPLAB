## 总览

### 要求

该lab要求我们完成四个函数，分别是`mm_init`、`mm_malloc`、`mm_free`和`mm_realloc`。即模拟标准malloc库的行为。

### 建议
该lab鼓励我们实现一个用于检查堆的工具函数`mm_check`，在每次进行malloc、free、realloc操作后调用该函数，检查堆的一致性。具体的检查可以检查以下几点：

- Is every block in the free list marked as free?
- Are there any contiguous free blocks that somehow escaped coalescing?
- Is every free block actually in the free list?
- Do the pointers in the free list point to valid free blocks?
- Do any allocated blocks overlap?
- Do the pointers in a heap block point to valid heap addresses?

当然这样的工具不是必须的，但是可以帮助我们更好的理解和调试我们的代码。这样的工具会占用大量的运行开销，所以在最终提交的时候需要将调用检查的代码删除。

### 提供的工具
在`memlib.c`文件中提供了一组用于模拟系统调用的函数，我们可以使用这些函数来模拟系统调用。

- **void *mem_sbrk(int incr)**: Expands the heap by incr bytes, where incr is a positive
non-zero integer and returns a generic pointer to the first byte of the newly allocated heap area. The
semantics are identical to the Unix sbrk function, except that mem sbrk accepts only a positive
non-zero integer argument.
- **void *mem_heap_lo(void)**: Returns a generic pointer to the first byte in the heap.
- **void *mem_heap_hi(void)**: Returns a generic pointer to the last byte in the heap.
- **size_t mem_heapsize(void)**: Returns the current size of the heap in bytes.
- **size_t mem_pagesize(void)**: Returns the system’s page size in bytes (4K on Linux systems).

### 规则
- 不应该改变`mm.c`中的任何接口
- 不应该使用任何与内存相关的系统调用或库函数，应该使用`memlib.c`中提供的函数
- 不应该在`mm.c`中定义任何全局数据结构（例如数组，链表，树），但是简单的内置类型是允许的
- 应该要和库函数的行为一致，总是返回8字节对齐的块

## 结构设计
我决定使用显式空闲链表来实现这个lab的要求。

### 显式空闲链表
显式空闲链表是一种双向链表，每个节点包含一个空闲块的地址和大小。这样的链表可以很方便的找到合适大小的空闲块。

为了提高分配器的效率，我们引入两个很有意思的机制：**伙伴系统**和**立即合并**。

- **伙伴系统**：我们将所有的空闲块的大小都设置为 2 的幂，同时维护一个链表头结点数组，假设最小的节点的有效载荷为 2<sup>n</sup>，则数组的第i个元素指向的就是有效载荷为 2<sup>(i+1)*n</sup>的空闲链表。当我们需要一个大小为 2<sup>k</sup> 的块时，我们尝试寻找到第一个可用的，大小为 j 的块（k <= j），如果k == j，那么很好，直接返回这个块。否则我们递归地二分这个块，直到块大小刚好为  2<sup>k</sup>，然后将每个剩下的半块加入到对应的空闲链表中。
- **立即合并**：当我们释放一个块时，我们立即检查其相邻的块是否是空闲的，如果是，我们就立即合并这两个块。这样可以避免出现连续的空闲块，为了得知相邻块的状态，我们需要在块的头部和尾部都存储一些信息。

### 显式空闲链表节点定义

每一个节点在**未分配**时，同时存储前一节点和后一节点的地址，便于进行取出和插入。同时也要存储该节点的大小，而且应该要在头尾都进行存储，便于进行合并节点的操作。

经过测试，该lab在编译时会将目标平台设置为32位，即**每个指针的大小为4字节。**

所以我决定将节点的**最小大小设置为16字节**，其中，8字节存储该节点的大小信息以及是否被分配，另外8字节存储前一节点和后一节点的地址，节点的大小应该是8的倍数。

空闲节点的具体结构如下：
```
+-------------------+-------------------+-------------------+..........+-------------------+
|       header      |       prev        |        next       |  bubble  |       footer      |
+-------------------+-------------------+-------------------+``````````+-------------------+
0(byte)             4                   8                   12     node_size - 4      node_size
```

在这样的结构中，`header`和`footer`都存储了该节点的大小信息和是否被分配，`prev`和`next`分别存储了前一节点和后一节点的地址。

`header`和`footer`的具体结构如下：
```
+----------------+---+
|   node_size    | A |
+----------------+---+
0                29  31(bit)
```
在4字节即32位的数据中，只有3位用于存储是否被分配（不止包括当前块是否被分别，甚至还应该包括前一个块是否被分配，**为了实现立即合并**），其余29位用于存储该节点的大小，这足够对应我们最大的堆大小（在`config.h`中定义为20mb）。

这样复杂的结构导致我们需要在需要取出这些值时进行一些指针操作（一个更简单的做法是使用结构体的位域定义，但是在规则下似乎不太适合这么做）。为此，我设置了一些宏用于取出这些值。

```c
// p 为一个已知地址的节点， 类型为 char *
#define GET_SIZE(p) (*(unsigned int *)p & 0x1fffffff) 
#define GET_ALLOC(p) ((*(unsigned int *)p & 0x80000000) >> 31) // 0 为未分配，1 为已分配
#define GET_PREV(p) (*(char * *)(p + 4))
#define GET_NEXT(p) ((*(char * *)(p + 8)))
#define GET_FOOTER(p) (*(unsigned int *)(p + GET_SIZE(p) - 4))
#define GET_SIZE_FROM_FOOTER(footer) (*(unsigned int *)(&footer) & 0x1fffffff) // 从footer中取出size
#define GET_ALLOC_FROM_FOOTER(footer) ((*(unsigned int *)(&footer) & 0x80000000) >> 31) // 从footer中取出alloc

// 从一个已知地址的节点中设置各种信息
#define SET_SIZE(p, size) (*(unsigned int *)p = (size | (0xe0000000 & *(unsigned int *)p))) // size 不应该超过 0x1fffffff
#define SET_ALLOC(p, alloc) (*(unsigned int *)p = (*(unsigned int *)p & 0x7fffffff) | (alloc << 31)) // alloc 只能为 0 或 1
#define SET_PREV(p, prev) (*(char * *)(p + 4) = prev)
#define SET_NEXT(p, next) (*(char * *)(p + 8) = next)
#define SET_FOOTER(p) (*(unsigned int *)(p + GET_SIZE(p) - 4) = *(unsigned int *)p) // 将header的信息复制到footer

#define TRUE 1
#define FALSE 0
```

### 空闲链表节点的有效载荷

一个节点的有效载荷和该节点的大小是两个不同的概念。有效载荷指的是我们分配给用户的空间，而节点的大小指的是整个节点的大小。在我们的设计中，**`有效载荷` = `节点的大小` - 8**。

下面解释为什么是这样的关系：

当我们分配了一个节点后，我们从空闲链表中取出该节点。然后设置一些东西，返回给用户一个指针指向有效载荷。

分配后的节点结构如下：
```
+-------------------+-------------------+-------------------+..........+-------------------+
|       header      |       bubble      |                   payload                        |
+-------------------+-------------------+-------------------+``````````+-------------------+
0                   4                   8                   12     node_size - 4      node_size
                                        ↑
                                        p
```

其中p代表我们返回给用户的指针，指向有效载荷。

为什么要将p设置为`node + 8`呢？首先我们肯定要保留`header`的信息，而为什么指向`+8`而不是`+4`呢？这是因为我们需要保证返回给用户的指针是8字节对齐的。

### 如何正确的合并节点

在释放一个节点后，我们需要检查其相邻的节点是否是空闲的，如果是，我们就立即合并这两个节点。

但是**我们需要一个方式来确定一个节点的前后是否是空闲的**。

对于后一个节点，这个问题很简单，我们只需要将当前节点的起始地址加上当前节点的大小，就可以得到后一个节点的起始地址，通过前面的宏，我们就可以得到后一个节点的信息。

但对于前一个节点，这个问题就有点复杂了。注意我们在将节点分配时为了让返回给用户的有效载荷最大化，有效载荷是包括了`footer`部分的。也就是说用户可以任意地修改有效载荷的内容，包括`footer`部分。所以我们不能直接通过`footer`部分来得到前一个节点的信息。

还好书中为我们提供了一个方案：
> 幸运的是，有一种非常聪明的边界标记的优化方法，能够使得在已分配块中不再需要脚部。回想一下，当我们试图在内存中合并当前块以及前面的块和后面的块时，只有在前面的块是空闲时，才会需要用到它的脚部。**如果我们把前面块的已分配/空闲位存放在当前块中多出来的低位中**，那么已分配的块就不需要脚部了，这样我们就可以将这个多出来的空间用作有效载荷了。不过请注意，空闲块仍然需要脚部。

书中提到如果将当前块是否已分配的信息存放到下一个块的低位中，那么我们就可以不需要脚部了。这样我们就可以将脚部的空间用作有效载荷了。

这就是为什么前面我们拿出三个bit用于存放是否分配的信息。

对于header我们作如下定义

```
+----------------+---+
|   node_size    | A |
+----------------+---+
0                29  31(bit)
                 ↑   ↑
             上一块  当前块 
```

如果从一段连续的内存来看
```
                                         此处被置1表示上一个块被分配
                                                        ↓
+-------------------+~~~~~~~~~~~~~~~~~~~+-------------------+~~~~~~~~~~~~~~~~~~~+
|       header      |     other data    |      header       |     other data    |
+-------------------+~~~~~~~~~~~~~~~~~~~+-------------------+~~~~~~~~~~~~~~~~~~~+
0                   4                   16                 ↑ 20
块1（总大小16字节，有效载荷8字节，已分配） 块2              此处被置0表示当前块未被分配                 
```

为了实现检查，我设计了一组宏用于设置和检查这些标志位
```c
// p 为一个已知地址的节点， 类型为 char *
// 为了和prev以及next区分，我们将前一个节点称为left，后一个节点称为right

// 当一个节点被分配时，调用该宏将下一个节点的上一节点标志位设置为已分配
#define SET_RIGHT_NODE_WHEN_ALLOC(p) (*(unsigned int *)(p + GET_SIZE(p)) = (*(unsigned int *)(p + GET_SIZE(p)) | 0x20000000))

// 当一个节点被释放时，调用该宏将下一个节点的上一节点标志位设置为未分配
#define SET_RIGHT_NODE_WHEN_FREE(p) (*(unsigned int *)(p + GET_SIZE(p)) = (*(unsigned int *)(p + GET_SIZE(p)) & 0xdfffffff))

// 检查上一节点是否被分配，不检查上一节点是否为NULL
#define IS_LEFT_ALLOC(p) ((*(unsigned int *)(p) & 0x20000000) >> 29)

// 检查下一节点是否被分配，不检查下一节点是否为NULL
#define IS_RIGHT_ALLOC(p) ((*(unsigned int *)(p + GET_SIZE(p)) & 0x80000000) >> 31)
```

注意检查上下节点是否被分配的宏都不检查是否上下节点是否为NULL以及是否到达当前堆的边界，这需要我们在代码中自行判断。

同时应该注意到最初的一个节点没有上一个节点指定它是否要设置标记位。为此我们可以用常用的带头节点的设计。将最初的一个节点设置为永远处于分配状态，这样即使合并进行到这里也会正确的停止。

而最后一个节点也面临着同样的问题，它没办法通过检查下一个节点的是否被分配标识来进行判断。为此我们也可以设置一个带尾节点的方案，永远保证在最后一个地方存在一个尾节点，它也永远处于被分配状态，这样即使合并进行到这里也会正常停止。

