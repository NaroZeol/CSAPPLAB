## 总览

### 要求

该lab要求我们完成四个函数，分别是`mm_init`、`mm_malloc`、`mm_free`和`mm_realloc`。即模拟标准malloc库的行为。

### 建议
该lab鼓励我们实现一个用于检查堆的工具函数`mm_check`，在每次进行malloc、free、realloc操作后调用该函数，检查堆的一致性。具体的检查可以检查以下几点：

- Is every block in the free list marked as free?
- Are there any contiguous free blocks that somehow escaped coalescing?
- Is every free block actually in the free list?
- Do the pointers in the free list point to valid free blocks?
- Do any allocated blocks overlap?
- Do the pointers in a heap block point to valid heap addresses?

当然这样的工具不是必须的，但是可以帮助我们更好的理解和调试我们的代码。这样的工具会占用大量的运行开销，所以在最终提交的时候需要将调用检查的代码删除。

### 提供的工具
在`memlib.c`文件中提供了一组用于模拟系统调用的函数，我们可以使用这些函数来模拟系统调用。

- **void *mem_sbrk(int incr)**: Expands the heap by incr bytes, where incr is a positive
non-zero integer and returns a generic pointer to the first byte of the newly allocated heap area. The
semantics are identical to the Unix sbrk function, except that mem sbrk accepts only a positive
non-zero integer argument.
- **void *mem_heap_lo(void)**: Returns a generic pointer to the first byte in the heap.
- **void *mem_heap_hi(void)**: Returns a generic pointer to the last byte in the heap.
- **size_t mem_heapsize(void)**: Returns the current size of the heap in bytes.
- **size_t mem_pagesize(void)**: Returns the system’s page size in bytes (4K on Linux systems).

### 规则
- 不应该改变`mm.c`中的任何接口
- 不应该使用任何与内存相关的系统调用或库函数，应该使用`memlib.c`中提供的函数
- 不应该在`mm.c`中定义任何全局数据结构（例如数组，链表，树），但是简单的内置类型是允许的
- 应该要和库函数的行为一致，总是返回8字节对齐的块

## 结构设计
我决定使用显式空闲链表来实现这个lab的要求。

### 显式空闲链表
显式空闲链表是一种双向链表，每个节点包含一个空闲块的地址和大小。这样的链表可以很方便的找到合适大小的空闲块。

为了提高分配器的效率，我们引入两个很有意思的机制：**分离适配**和**立即合并**。

- **分离适配**：我们将空闲块按照大小进行分组。每一组固定一个最小大小，当我们需要一个大小为n的空闲块时，我们只需现在最小大小小于n和最大大小大于n的组中找到一个满足条件的块即可。然后如果这个块在分配给用户后还有大量的空余，我们选择将其进行分割，将剩余的部分放入对应的组中。
- **立即合并**：当我们释放一个块时，我们立即检查其相邻的块是否是空闲的，如果是，我们就立即合并这两个块。这样可以避免出现连续的空闲块，为了得知相邻块的状态，我们需要在块的头部和尾部都存储一些信息。

### 显式空闲链表节点定义

每一个节点在**未分配**时，同时存储前一节点和后一节点的地址，便于进行取出和插入。同时也要存储该节点的大小，而且应该要在头尾都进行存储，便于进行合并节点的操作。

经过测试，该lab在编译时会将目标平台设置为32位，即**每个指针的大小为4字节。**

所以我决定将节点的**最小大小设置为16字节**，其中，8字节存储该节点的大小信息以及是否被分配，另外8字节存储前一节点和后一节点的地址，节点的大小应该是8的倍数。

空闲节点的具体结构如下：
```
+-------------------+-------------------+-------------------+..........+-------------------+
|       header      |       prev        |        next       |  bubble  |       footer      |
+-------------------+-------------------+-------------------+``````````+-------------------+
0(byte)             4                   8                   12     node_size - 4      node_size
```

在这样的结构中，`header`和`footer`都存储了该节点的大小信息和是否被分配，`prev`和`next`分别存储了前一节点和后一节点的地址。

`header`和`footer`的具体结构如下：
```
+----------------+---+
|   node_size    | A |
+----------------+---+
0                29  31(bit)
```
在4字节即32位的数据中，只有3位用于存储是否被分配（不止包括当前块是否被分别，甚至还应该包括前一个块是否被分配，**为了实现立即合并**），其余29位用于存储该节点的大小，这足够对应我们最大的堆大小（在`config.h`中定义为20mb）。

这样复杂的结构导致我们需要在需要取出这些值时进行一些指针操作（一个更简单的做法是使用结构体的位域定义，但是在规则下似乎不太适合这么做）。为此，我设置了一些宏用于取出这些值。

```c
// p 为一个已知地址的节点， 类型为 char *
#define GET_SIZE(p) (*(unsigned int *)p & 0x1fffffff) 
#define GET_ALLOC(p) ((*(unsigned int *)p & 0x80000000) >> 31) // 0 为未分配，1 为已分配
#define GET_PREV(p) (*(char * *)(p + 4))
#define GET_NEXT(p) ((*(char * *)(p + 8)))
#define GET_FOOTER(p) (*(unsigned int *)(p + GET_SIZE(p) - 4))
#define GET_SIZE_FROM_FOOTER(footer) (*(unsigned int *)(&footer) & 0x1fffffff) // 从footer中取出size
#define GET_ALLOC_FROM_FOOTER(footer) ((*(unsigned int *)(&footer) & 0x80000000) >> 31) // 从footer中取出alloc

// 从一个已知地址的节点中设置各种信息
#define SET_SIZE(p, size) (*(unsigned int *)p = (size | (0xe0000000 & *(unsigned int *)p))) // size 不应该超过 0x1fffffff
#define SET_ALLOC(p, alloc) (*(unsigned int *)p = (*(unsigned int *)p & 0x7fffffff) | (alloc << 31)) // alloc 只能为 0 或 1
#define SET_PREV(p, prev) (*(char * *)(p + 4) = prev)
#define SET_NEXT(p, next) (*(char * *)(p + 8) = next)
#define SET_FOOTER(p) (*(unsigned int *)(p + GET_SIZE(p) - 4) = *(unsigned int *)p) // 将header的信息复制到footer

#define TRUE 1
#define FALSE 0
```

### 空闲链表节点的有效载荷

一个节点的有效载荷和该节点的大小是两个不同的概念。有效载荷指的是我们分配给用户的空间，而节点的大小指的是整个节点的大小。在我们的设计中，**`有效载荷` = `节点的大小` - 8**。

下面解释为什么是这样的关系：

当我们分配了一个节点后，我们从空闲链表中取出该节点。然后设置一些东西，返回给用户一个指针指向有效载荷。

分配后的节点结构如下：
```
+-------------------+-------------------+-------------------+..........+-------------------+
|       header      |       bubble      |                   payload                        |
+-------------------+-------------------+-------------------+``````````+-------------------+
0                   4                   8                   12     node_size - 4      node_size
                                        ↑
                                        p
```

其中p代表我们返回给用户的指针，指向有效载荷。

为什么要将p设置为`node + 8`呢？首先我们肯定要保留`header`的信息，而为什么指向`+8`而不是`+4`呢？这是因为我们需要保证返回给用户的指针是8字节对齐的。

### 如何正确的合并节点

在释放一个节点后，我们需要检查其相邻的节点是否是空闲的，如果是，我们就立即合并这两个节点。

但是**我们需要一个方式来确定一个节点的前后是否是空闲的**。

对于后一个节点，这个问题很简单，我们只需要将当前节点的起始地址加上当前节点的大小，就可以得到后一个节点的起始地址，通过前面的宏，我们就可以得到后一个节点的信息。

但对于前一个节点，这个问题就有点复杂了。注意我们在将节点分配时为了让返回给用户的有效载荷最大化，有效载荷是包括了`footer`部分的。也就是说用户可以任意地修改有效载荷的内容，包括`footer`部分。所以我们不能直接通过`footer`部分来得到前一个节点的信息。

还好书中为我们提供了一个方案：
> 幸运的是，有一种非常聪明的边界标记的优化方法，能够使得在已分配块中不再需要脚部。回想一下，当我们试图在内存中合并当前块以及前面的块和后面的块时，只有在前面的块是空闲时，才会需要用到它的脚部。**如果我们把前面块的已分配/空闲位存放在当前块中多出来的低位中**，那么已分配的块就不需要脚部了，这样我们就可以将这个多出来的空间用作有效载荷了。不过请注意，空闲块仍然需要脚部。

书中提到如果将当前块是否已分配的信息存放到下一个块的低位中，那么我们就可以不需要脚部了。这样我们就可以将脚部的空间用作有效载荷了。

这就是为什么前面我们拿出三个bit用于存放是否分配的信息。

对于header我们作如下定义

```
+----------------+---+
|   node_size    | A |
+----------------+---+
0                29  31(bit)
                 ↑   ↑
             上一块  当前块 
```

如果从一段连续的内存来看
```
                                         此处被置1表示上一个块被分配
                                                        ↓
+-------------------+~~~~~~~~~~~~~~~~~~~+-------------------+~~~~~~~~~~~~~~~~~~~+
|       header      |     other data    |      header       |     other data    |
+-------------------+~~~~~~~~~~~~~~~~~~~+-------------------+~~~~~~~~~~~~~~~~~~~+
0                   4                   16                 ↑ 20
块1（总大小16字节，有效载荷8字节，已分配） 块2              此处被置0表示当前块未被分配                 
```

为了实现检查，我设计了一组宏用于设置和检查这些标志位
```c
// p 为一个已知地址的节点， 类型为 char *
// 为了和prev以及next区分，我们将前一个节点称为left，后一个节点称为right

// 当一个节点被分配时，调用该宏将下一个节点的上一节点标志位设置为已分配
#define SET_RIGHT_NODE_WHEN_ALLOC(p) (*(unsigned int *)(p + GET_SIZE(p)) = (*(unsigned int *)(p + GET_SIZE(p)) | 0x20000000))

// 当一个节点被释放时，调用该宏将下一个节点的上一节点标志位设置为未分配
#define SET_RIGHT_NODE_WHEN_FREE(p) (*(unsigned int *)(p + GET_SIZE(p)) = (*(unsigned int *)(p + GET_SIZE(p)) & 0xdfffffff))

// 检查上一节点是否被分配，不检查上一节点是否为NULL
#define IS_LEFT_ALLOC(p) ((*(unsigned int *)(p) & 0x20000000) >> 29)

// 检查下一节点是否被分配，不检查下一节点是否为NULL
#define IS_RIGHT_ALLOC(p) ((*(unsigned int *)(p + GET_SIZE(p)) & 0x80000000) >> 31)
```

注意检查上下节点是否被分配的宏都不检查是否上下节点是否为NULL以及是否到达当前堆的边界，这需要我们在代码中自行判断。

然后我们需要一个方式来知道合并操作是否到达了堆的边界。我们也可以提供一系列的宏来进行判断。

```c
// p 为一个已知地址的节点， 类型为 char *

// 判断是否为有效节点的最左边
#define IS_LEFTEST(p) (p == mem_heap_lo() + 112)

// 判断是否为堆的最右边
#define IS_RIGHTEST(p) (p + GET_SIZE(p) == mem_heap_hi())
```

### 初始化工作

在准备好了这些宏之后，我们就可以开始进行初始化工作了。

我们使用一个数组来存储空闲链表的头结点，数组的每一个元素指向的是一个空闲链表的头结点。

同时，因为不建议定义全局数据结构（包括数组），所以我们要手动使用`mem_sbrk`来分配一些空间来存储这些头结点。

因为最大堆的大小为20mb，同时空闲链表的最小节点大小为16字节，所以我们设置从16到20mb的每个2的幂的空闲链表的头结点。

20mb = 20 * 1024 * 1024 = 20971520

以0为数组的最小下标，每一个下标对应的空闲链表的最小大小为2<sup>(i+4)</sup>，所以我们需要的数组大小为 4 + log<sub>2</sub>(20971520) = 4 + 24 = 28。

如下表所示

| 下标 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 |
| - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | -| - | - | - | 
| 最小大小 | 16 | 32 | 64 | 128 | 256 | 512 | 1024 | 2048 | 4096 | 8192 | 16384 | 32768 | 65536 | 131072 | 262144 | 524288 | 1048576 | 2097152 | 4194304 | 8388608 | 16777216 | 33554432 | 67108864 | 134217728 | 268435456 | 536870912 | 1073741824 | 2147483648 |
| 最小有效载荷 | 8 | 24 | 56 | 120 | 248 | 504 | 1016 | 2032 | 4088 | 8184 | 16376 | 32760 | 65528 | 131064 | 262136 | 524280 | 1048568 | 2097144 | 4194296 | 8388592 | 16777184 | 33554368 | 67108736 | 134217720 | 268435448 | 536870904 | 1073741820 | 2147483640 |

我们需要的数组大小为28，所以我们需要分配 28 * 4 = 112 字节的空间，然后将首地址赋值给一个全局变量。

```c
// 初始化空闲链表的头结点
void mm_init(void) {
    // 分配空间
    free_list = mem_sbrk(112);
    // 初始化空闲链表
    for (int i = 0; i < 28; i++) {
        free_list[i] = NULL;
    }
}
```

一个大致的链表结构如下所示（注意为了节约内存我没有使用带头结点的方案）：

```
0          1          2
+----------+----------+----------+........
↓          ↓          ↓
○(20字节)  ○(38字节)   NULL
↓
○(18字节)
```

### 如何分配节点

这个是我们最关心的问题。

在显式空闲链表中，一个块的大小是按照当前块的实际大小进行分组的。而用户能够拿到的有效载荷等于当前块的大小减去8字节。

所以当给定一个用户希望分配的size时，我们先将其向8的倍数取整然后加上8字节.
```c
int newsize = ALIGN(size + SIZE_T_SIZE) + 8;
```

接着我们用二分查找，找到一个最小大小小于`newsize`中的最大的组。
```c
int left = 0;
int right = groupSize - 1;

while (left <= right) {
    int mid = (left + right) / 2;
    if (newsize <= (1 << (mid + 4))) {
        right = mid - 1;
    } else {
        left = mid + 1;
    }
}
```

我们从这个组开始遍历，寻找一个满足需求的块
```c
for (int i = right; i < groupSize; i++) {
    if (free_lists[i] != NULL) {
        char *p = free_lists[i];
        while (p != NULL) {
            if (GET_SIZE(p) >= newsize) {
                res = p;
                indexOfRes = i;
                is_find = TRUE;
                break;
            }
            p = GET_NEXT(p);
        }
    }
    if (is_find) {
        break;
    }
}
```

如果找到了一个满足要求的块，那么将它从链表中取出。
```c
    // 将节点与原链表断绝关系
    char *pre = GET_PREV(res);
    char *next = GET_NEXT(res);
    // 与前节点断绝关系
    if (pre == NULL) {// 为了便于操作，我们将位于最上方的链表节点的前驱设置为NULL，这样就可以分辨是否是最上方节点
        free_lists[indexOfRes] = next;
    }else{
        SET_NEXT(pre, next);
    }
    // 与后节点断绝关系
    if (next != NULL) { // 如果本身就是最后一个节点，就什么都不用做
        SET_PREV(next, pre); 
    }
```

然后我们比较这个块的有效载荷与用户希望获得的size之间的差距，如果差距大于等于16字节，我们就将这个块进行分割，再次使用二分查找找到一个适合放置剩余块的组，然后将剩余块加入到对应的链表中。

随后返回给用户一个指向有效载荷的指针。

如果没有找到满足要求的块，我们就需要调用`mem_sbrk`来分配一些新的空间。并进行相应的初始化，然后将有效载荷返回给用户。

### 如何从一个已分配的有效载荷中找到对应的节点的各种信息

为了从一个已分配的有效载荷中找到对应的节点的各种信息，我们需要通过指针运算来得到节点的头部地址。
```c
#define GET_NODE_FROM_PAYLOAD(p) (p - 8)
```

这样我们就获取到了节点的头部地址。

接着我们进行一系列设置，将节点的状态恢复至未分配状态。
```c
SET_ALLOC(node, FALSE);
SET_FOOTER(node);
SET_RIGHT_NODE_WHEN_FREE(node);
```

### 合并操作

为了最大的利用空间，我们需要在释放一个节点后检查它是否能和周围的节点进行合并。

首先我们需要检查它的前一个节点和后一个节点是否是空闲的，如果是，我们就进行合并操作，这样的操作是可递归的，所以我们使用一个函数来完成这个操作。

